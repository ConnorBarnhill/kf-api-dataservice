# Kids First UID Design Considerations

This document contains design considerations and is not a specification.

---

## Notes

* Key generation (how many bits, how they're allocated) is distinct from encoding (which characters to use).
* Many encoding techniques have functional disconnects between goal and implementation, e.g.
  * **ulid** says "No special characters (URL safe)", but it's not necessary to use *no* special characters to be URL safe! **$-_.+!*'(),** are all safe without urlencoding and significantly visually distinct.
  * **Crockford's Base32 encoding** says "[uppercase] L Can be confused with 1". This flies in the face of all available evidence. What font does that? Why not also remove G/6, B/8, Z/2, or S/5 then?
* Many key encoding techniques make up arbitrary rules that apply only to very specific scenarios.
  * **Crockford's Base32 encoding** says "Humans should be able to accurately transmit the symbols to other humans using a telephone." This is not a valid concern for our system. That is good for when you need to call a customer service agent and tell them your account ID number, which is very far removed from any of our use cases. We have no scenarios where this restriction should apply.
* **Randomness never guarantees uniqueness.** Ever. Regardless of the number space or generator strength. We can do better than that.
* None of the 5 basic UUID/GUID variants described on wikipedia.org/wiki/Universally_unique_identifier ensure uniqueness. They are all misnamed.

## We definitely want

* Eliminate key reuse and collisions
* Compact representation
* Visually differentiable (no commonly hyperambiguous characters)
* Typable

## We don't need

(many systems value these things for sometimes legitimate and sometimes illegitimate reasons)

* Chronological sorting (though recording time is useful for uniqueness)
* Reading out loud over the phone
* Easy typing on mobile keyboards
* Checksums

## We don't know if we need

* Decentralized generation (could rule out keyservers)

---

## Key Generation Techniques

(randomness, external incrementer, internal incrementer, physical ID, logical ID)

### Methods for differentiating my own keys from each other

* Random generation in a very large space
  * <font color="darkorange">Insufficient. Improbable things happen all the time.</font>
* Counting
  * <font color="lightseagreen">Guaranteed for serial generation within max_increment.</font>
* Timestamp
  * <font color="lightseagreen">Guaranteed for extra-interval generation.</font>

### Methods for differentiating my keys from someone else's keys

* Random generation in a very large space
  * <font color="darkorange">Insufficient. Improbable things happen all the time.</font>
* Generator hardware address (e.g. prefix with MAC)
  * <font color="crimson">Hardware address may not be stable. Hardware address is also the same for all processes on one device. Both defeat the purpose.</font>
* Unique process ID per generator
  * <font color="lightseagreen">Guaranteed, but requires negotiation to assign a unique ID to each process.</font>

### Who uses what? ULID vs TUID vs Twitter vs Instagram vs Flickr, etc

* **Twitter (snowflake)** uses <font color="lightseagreen">a timestamp, a node ID, and a counter</font>
* **Instagram** uses a <font color="lightseagreen">timestamp, a node ID, and a counter</font>
* **Flickr** uses <font color="lightseagreen">a central ticket server</font> with a simple <font color="lightseagreen">counter</font>
  * (technically multiple servers where the number space is subdivided among them to avoid single-point-of-failure)
* **TUID** uses <font color="lightseagreen">a timestamp, a node ID, a counter, <font color="darkorange">and some random bits</font></font>
* **ULID** uses <font color="lightseagreen">a timestamp and a counter <font color="darkorange">that starts randomized</font></font>
* **MongoDB ObjectId** uses <font color="lightseagreen">a timestamp, <font color="darkorange">some random bits</font>, and a counter <font color="darkorange">that starts randomized</font></font>

### Node IDs

Including unique Node IDs guarantees that UIDs generated by different nodes will always be different.

### Node IDs always require coordination

Node IDs can either be manually assigned or automatically assigned, but in all cases they have to come from a central registry so that they don't get reused.

### Counters

If you always increment the next UID, UIDs generated by a single generator will always be unique.

### Adding Counters to Node IDs

If a Node ID differentiates my keys from your keys, and a counter differentiates my keys from my keys, then
combining the two guarantees uniqueness.

### Timestamps

Including a timestamp guarantees that two UIDs generated at noticably different system times will always be different.

### Timestamp complications

* Your system clock can be wrong and/or run backwards!
  * Any implementation using timestamps needs to be robust to that or the system needs to be configured to prevent it. See: https://web.archive.org/web/20180305011043/https://wiki.dovecot.org/TimeMovedBackwards<br>
    * **Solution for server-side generation:** Update the clock and then force ntpd into slew mode with `-x, --slew` before starting the dataservice.
    * **Solution for client-side generation:** Cry a lot. Just kidding. See the section on **Client-side generation**.

### Adding Sub-chronon Counters to Timestamps

(A chronon is the smallest unit of quantized time)

Adding sub-chronon counters to timestamps extends the difference guarantee to UIDs generated faster than the timestamp can differentiate. The sub-chronon counter increments whenever `previous_max_timestamp >= this_timestamp`.

This also mitigates issues if the system clock moves backwards as long as the timestamp passes previous_max_timestamp before the counter is exhausted. The alternative is to block the generating process and wait until time has moved forward again, which uses fewer bits (or allocates more bits to other things) but is potentially dangerous, because a time jump could lead to waiting for a long time.

### Timestamp + Sub-chronon Counter initial state randomization

Starting the counter at a random value credibly adds another small layer of protection at zero cost. If two nodes are not assigned Node IDs (or are given the exact same Node ID because of an error) and then generate keys at the exact same time, randomizing the counters' initial values could disambiguate them. Like all randomization, though, this guarantees nothing.

### Timestamp + Sub-chronon Counter exhaustion

If the counter's numeric capacity is fully exhausted before the next time step, it becomes prudent to block the process until the next time step.

### Timestamps vs Node IDs

Using **[Node ID + Counter]** even without any timestamp is sufficient for guaranteed uniqueness (assuming that the Node IDs are assigned uniquely) but requires Node ID assignment.

Using **[Timestamp + Randomized Sub-chronon Counter]** without a Node ID guarantees nothing but is likely sufficiently robust against collisions for our purposes because we have no real threat of simultaneous key generation.

### Random bits vs Node IDs

 When attached to a counter or timestamp+counter, random bits and Node IDs fill the same general role. They both say "If two different processes generate IDs at the _exact_ same time, please don't assign the same UIDs."

The difference is that generating random bits only *probably* produces different results, while uniquely assigning Node IDs will guarantee it. Random bits are easier to generate in a vacuum, of course, because Node IDs need to be assigned by a central node registry, but generating IDs in a total vacuum may be a somewhat silly constraint for a system that is talking to the dataservice anyway.

---

## Key Encoding

| Bits | Base32 Digits |
|-|-|
|64|13|
|96|20|
|128|26|
|160|32|
|192|39|

| Bits | Base57 Digits |
|-|-|
|64|11|
|96|17|
|128|22|
|160|28|
|192|33|

#### Because of how we name study buckets, we are currently constrained for studies by Amazon S3 Bucket naming rules, which stipulate:

* The bucket name ... can contain only lower-case characters, numbers, periods, and dashes.
* Each label in the bucket name must start with a lowercase letter or number.
* The bucket name cannot contain underscores, end with a dash, have consecutive periods, or use dashes adjacent to periods.

#### This means that we do one of:

1. Limit ourselves to just numbers and a single lettercase for encoding.
2. Use different ID styles for everything other than studies.
3. Uncouple kfids from bucket names.

#### If we choose 2 or 3...

### Modifying Crockford's Base32 symbol set

Crockford's Base32 symbol set is <font color="crimson"><ins>not perfect</ins></font> for our purpose.

#### Explanation

Rationales given by the design make very little sense or are self-defeating, negating any benefits from the loss of symbols.

* Reducing 1/I/i/L/l to just 1 does nothing to resolve visual ambiguity for the user, because a user could just as easily read l or I instead of 1 and O instead of 0. We shouldn't demand that users internalize arbitrary technical implementation details.
* Symbol set reductions (like from 1/I/i/L/l to 1) assume that a computer system will flexibly allow the user to enter something wrong but visually similar and then convert to the canonical symbols for uniformity. But that wouldn't help users who would look at 111 and LLL and say to themselves "but those are clearly different".
* Capital letter L can't actually be confused with the number 1 in any font that I've ever seen, so why do we lose it?

#### Possible Fix

* Avoid _**both**_ parts of commonly visually ambiguous pairs, by replacing numbers "1" and "0" with capital letter "L" and "*" respectively.

### Higher Bases

What alphabet we use for encoding comes down to arbitrary gut feelings. https://github.com/skorokithakis/shortuuid lets you use whatever alphabet you want, which makes it a good candidate for our encoding no matter what we choose.

* shortuuid defaults to using base57's "**23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz**", which is like base58 but better, because base58 adds in "1" which we already know is commonly visually ambiguous.

---

## 64 bit Keys Can Provide (examples)...

### Server ID + Counter

* 19 bits for Server ID (500 thousand different servers)
* 45 bits for Counter
  * 35 trillion UIDs per server
  * If exhausted (lol), request a new Server ID

### Session ID + Counter

* 44 bits for Session ID (17 trillion sessions)
* 20 bits for Counter
  * 1 million UIDs per session
  * If exhausted (lol), get a new Session ID

### Millisecond Timestamp + Node ID + Randomized Sub-chronon Counter

* 41 bits for milliseconds since custom epoch (from now until 69.5 years from now)
* 10 bits for Node ID
  * 1 thousand nodes
* 13 bits for randomized counter
  * 8 thousand keys per millisecond per node

### Second Timestamp + Node ID + Randomized Sub-chronon Counter

* 31 bits for seconds since custom epoch (from now until 69.5 years from now)
* 20 bits for Node ID
  * 1 million nodes
* 13 bits for randomized counter
  * 8 thousand keys per second per node

## Nodeless keys need to be larger (eg 128/160 bits)

In base57, 128 and 160 bit keys are still palatable, so you could combine a timestamp with a wide (64, 87, 119, or 129 bits) randomized counter and get ID-less generation, which, while not fully guaranteed, would still be much safer than a UUID.
